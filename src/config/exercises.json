[
    {
        "code": "/**\n * Can you tell the result before executing the code and explain why?\n */\n\nfunction run(callback) {\n\tsetTimeout(callback);\n\tconsole.log(\"I'm running!\");\n}\n\nfunction eatStew() {\n\tconsole.log(\"I'm eating a porotos stew!\");\n}\n\nrun(eatStew);\n"
    },
    {
        "code": "/**\n * How would you refactor this to the async/await pattern\n */\n\nfetch(\"https://rickandmortyapi.com/api/character\")\n\t.then((response) => response.json())\n\t.then((response) => console.log(response.results))\n\t.catch((error) => console.error(error));\n"
    },
    {
        "code": "/*\n * Given that the function getCharacter is calling the API everytime you type something\n * on the input you'll see on the top of the screen once you run the exercise...\n *\n * How would you optimize this using the event loop?\n */\n\n/*\n * Fetches a filtered (by name) list  of characters from the Rick & Morty API\n */\nasync function getCharacter(name) {\n\tconsole.clear();\n\tconst data = await (await fetch(`https://rickandmortyapi.com/api/character/?name=${name}`)).json();\n\tdata.error ? console.log(`Error: ${data.error}`) : console.log(data.results.map((x) => x.name));\n}\n\n\n\n\n// ⚠️ Ignore this...\n// --------------------\nconst inputId = \"name-input\";\nlet existentInput = document.querySelector(`#${inputId}`);\n\nif (!existentInput) {\n\tconst input = document.createElement(\"input\");\n\tinput.placeholder = \"Type a name here...\";\n\n\tObject.assign(input.style, {\n\t\tposition: \"fixed\",\n\t\ttop: \"25px\",\n\t\tleft: \"50%\",\n\t\ttransform: \"translateX(-50%)\",\n\t\tpadding: \"10px 15px\",\n\t\tborder: \"1px solid #444\",\n\t\tborderRadius: \"5px\",\n\t\tfontSize: \"18px\",\n\t\ttextAlign: \"center\",\n\t\tminWidth: \"250px\",\n\t\tzIndex: 100,\n\t});\n\n\tinput.id = inputId;\n\tdocument.body.append(input);\n\tinput.addEventListener(\"keyup\", (e) => getCharacter(e.target.value));\n\texistentInput = input;\n} else {\n\texistentInput.value = \"\";\n}\n\nwindow.setExerciseTrashCleaner(() => existentInput.remove());\n"
    },
    {
        "code": "/**\n * Given this code...\n * How would you refactor the async operation to be more performant\n * Hint: you could trigger all at once 😉\n */\n\nconst endpoints = {\n\tcharacter: \"https://rickandmortyapi.com/api/character\",\n\tlocation: \"https://rickandmortyapi.com/api/location\",\n\tepisode: \"https://rickandmortyapi.com/api/episode\",\n};\n\nasync function getDataFrom(endpoint) {\n\treturn fetch(endpoint)\n\t\t.then((response) => response.json())\n\t\t.then((json) => json)\n\t\t.catch((error) => console.error(error));\n}\n\n(async () => {\n\tconst characters = await getDataFrom(endpoints.character);\n\tconst location = await getDataFrom(endpoints.location);\n\tconst episode = await getDataFrom(endpoints.episode);\n\n\tconsole.log(characters, location, episode);\n})();\n"
    },
    {
        "code": "/**\n * What will be the result of this chaining?\n * Once you have the result, can you explain why?\n */\n\nconst somePromise = new Promise((resolve, _) => resolve(2));\n\nsomePromise\n\t.then((value) => {\n\tconsole.log(value);\n\treturn Promise.resolve(value * 2);\n})\n\t.then((value) => {\n\tconsole.log(value);\n\treturn Promise.reject(value * 2);\n})\n\t.catch((value) => {\n\tconsole.log(value);\n\treturn Promise.resolve(value * 2);\n})\n\t.then((value) => {\n\tconsole.log(value);\n\treturn Promise.resolve(value * 2);\n});\n"
    }
]
